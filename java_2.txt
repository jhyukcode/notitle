1. CLASS
  (1) 자바의 저장 단위
    - 변수 < 배열 < 클래스명
  (2) 객체의 특징
    - 부품객체
    - 상태(멤버변수)와 행위(멤버함수)를 갖는다

  OOP란??
    - 객체	지향	프로그래밍
    - Object Oriented Programming
    - 클래스(부품객체)를 조립해서 완성해가는 프로그램
  CLASS vs INSTANCE
    - 클래스(설계도) 틀로 여러 개의 객체(인스턴스)들을 만들 수 있음
    - 붕어빵 기계(설계도) --> 붕어빵들(객체)
      인스턴스화(heap:실제 만들었는지 확인), 인스턴스 : 각각의 특징
    - 클래스(부품객체) 특징에 맞게 코딩
    - 상태(멤버변수)와 행위(멤버함수)

2-1. 생성자 
  (1) 생성자
    - new 연산자에 의해 호출 [초기화] 담당
  (2) 기본 생성자 (디폴트 생성자)
    - 모든 클래스에 생성자가 반드시 존재
    - 생성자 선언을 생략 시 컴파일러가 자동으로 기본 생성자를 추가
    - 개발자가 선언 시 컴파일러가 자동 생성 취소

2-2. 생성자 형식
  class A{
    public A(){}    기본생성자
    public A(String name){}   파라미터 알규먼트가 있는 생성자
  }
  (1) 리턴값 없음 >  리턴값 메서드명(파라미터)
  (2) 클래스명과 동일
  (3) 기본 생성자를 생성해야 하는 경우 : 오버로딩, 상속

3. static
  (1) runtime data area
    - method : 정보저장, static final
    - heap : 동적저장 - new, garbage collector가 처리소멸
    - stack : 임시값 저장

  (2) static
    - jvm 소스 로딩 시 메모리를 할당 받음
    - new 연산자보다 먼저 실행되어 메모리(method영역:runtime)에 1회 생성
    - 클래스명.변수명 / 클래스명.메서드명 - 클래스변수/클래스메서드
    - 객체 생성과 관련이 없음
    - 인스턴스로 접근 시 권장사항이 아니므로 경고 발생

4. 초기화 순서
  기본값      명시적 초기화         초기화 블록       생성자

  (1) 기본값
    > String, 객체 - null
    > int - 0
  (2) 명시적 초기화 
    > int a = 10;
    - 중요 콘텐츠 명시적으로 알림
  (3) 초기화 블록 
    > { a = 10; b = 10;}
    - 여러 개 초기화 시
  (4) 생성자
    - 최종은 생성자에서 사용함
    - 인스턴스 변수 초기화

5. 지정 접근자
  - 클래스 및 구성 요소에 대한 접근 제한 역할
                          클래스내부  패키지  하위클래스  그외
    public                O           O      O          O        
    protected             O           O      O(extneds) X
    default(package)      O           O      X
    private               O           X      X          X

6. 클래스 배열
  클래스[] 배열명 = new 클래스[];
  클래스 배열 내에 값 입력 시
   생성자를 호출하여 인스턴스 변수를 초기화 해 사용 가능하게 만들어야 함
   배열명[배열넘버] = new 클래스명();

7. 상속
  (1) 클래스의 재사용
    - 새로운 부분만 추가, 수정해서 사용
  (2) super | sub
      부모    자식
      상위    하위
      parent  child
      super   sub
  (3) 모든 클래스는 Object 클래스를 상속
  (4) UML : 부모 <- 자식
  (5) 장점
    - 빠른 개발
    - 코드의 중복성 제거
    - 다형성(하나의 타입으로 여러 타입을 관리)
  (6) 문법
    - class 'sub' extends 'super'
      > 상속은 단일 상속(다중상속불가)만 가능하다
  [!] 상속 시 부모 속성을 사용할 수 있는 이유
    > 부모 생성자를 호출하여 부모의 인스턴스 변수를 초기화해 사용 가능하게 만듦.
  (7) 오버라이드
    - @Overide
    - 상속(extends)시 부모의 메서드와 동일한지 확인

8. 클래스 다이어그램
 - 시스템을 구성하는 클래스들 사이 관계를 표현
 - 클래스 : 객체를 생성하는 설계도
 > https://staruml.io/
  (1) 사용법
  (2) UML 관계
    1. 연관관계
     
    2. 일반화관계
      - 상속 관계
      - IS-A 관계 
        : 한 클래스가 다른 클래스를 포함하는 상위 개념
    3. 집합관계
    4. 의존관계
    5. 실체화관계(인터페이스)

9. 다형성
  - 많은 형상을 듸는 성품
  - 여러 타입의 객체를 하나의 타입으로 관리
  (1) 부모는 자식을 담을 수 있다 (업캐스팅)
  (2) 자식은 부모를 담을 수 있다 (다운캐스팅)
    > 단, 부모가 자식을 담은 적이 있어야 한다
  (3) 다형성의 필요성
     - 부모 타입으로 자식 객체들을 관리 가능